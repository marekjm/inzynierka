\section{Architektura}

\subsection{Użyte wzorce projektowe}

\subsection{Architektura systemu}
\label{chat_architektura_systemu}

Architektura systemu opiera się na klasycznym modelu klient-serwer.

Klienci będą uzyskiwali dostęp do usługi czatu za pośrednictwem przeglądarki
internetowej. Łącząc się z podanym adresem (IP lub domeny), na którym połączeń
nasłuchuje serwer, w pierwszej kolejności przeglądarka będzie próbować połączyć
się z nim przy użyciu protokołu http i standardowego portu 80, wysyłając do
niego żądanie metodą GET. Wówczas, serwer będzie zawsze odpowiadał statycznym
plikiem HTML, zawierającym odwołania do skryptów w języku JavaScript (JS) oraz
pozostałej, statycznej treści (np. grafiki czy arkusze stylów CSS). Serwer
będzie odsyłał te pliki do przeglądarki w odpowiedzi na kolejne żądania HTTP
GET, wysyłane w miarę dalszego renderowania pliku HTML. W ten sposób, po stronie
klienta zostanie pobrana i uruchomiona aplikacja internetowa typu Single Page
Application, której interfejs będzie reagował z użytkownikiem oraz ulegał
zmianom wskutek działania skryptów JS, załadowanych na pierwszym etapie
uruchomienia. Po stronie serwera, dostarczaniem treści statycznych będzie
zajmował się daemon HTTP - Nginx.

Gdy tylko skrypty JS wykryją pobranie wszystkich plików składowych aplikacji
z serwera, podjęta zostanie próba nawiązania połączenia z tym serwerem przy
użyciu protokołu WebSocket. Będzie on od tego momentu podstawowym kanałem
komunikacji pomiędzy klientem a serwerem.

Zgodnie ze standardem WebSocketu, zanim zostanie nawiązane właściwe połączenie,
powinno dojść do „uścisku dłoni” (ang. \textit{handshake}) pomiędzy klientem a
serwerem. W związku z tym, pierwsza próba połączenia również zostanie podjęta
przy użyciu protokołu http, jednakże tym razem pod innym, dedykowanym portem
(w naszym przypadku będzie to port 8000), a także zawierać nagłówki wskazujące
na żądanie zmiany używanego protokołu na WebSocket, jego wersję oraz klucz
(„Sec-WebSocketKey”). Serwer udzieli wówczas odpowiedzi ze swoim własnym
kluczem, informując o zmianie stosowanego protokołu na WebSocket.

\subsection{Dekompozycja systemu na podsystemy}
\label{architektura_chatu}

\subsubsection{Backend}
Za nasłuchiwanie na porcie 8000 po stronie serwera będzie odpowiadał aktor
,,WSListener'', który przy pierwszej próbie połączenia utworzy kolejnego,
niezależnego aktora ,,WSInitializer'', odpowiadającego za realizację ,,uścisku
dłoni'' i formułowanie odpowiedzi zwrotnej po stronie serwera w odniesieniu do
połącznia na konkretnym gnieździe. W razie prawidłowego nawiązania połączenia,
aktor ten utworzy kolejną parę aktorów, ,,WSConnector'' oraz ,,Authorizer'', zaś
sam WSInitializer ulegnie samozniszczeniu.

Od tej pory, ,,WSConnector'' będzie odpowiadał za dalszą, bezpośrednią obsługę
przydzielonego gniazda. Jego rolą będzie również kodowanie i dekodowanie
wiadomości (ang.,,messages''), czyli podstawowych logicznych jednostek
informacji, które są używane przy połączeniach z użyciem protokołu WebSocket.
Z kolei ,,Authorizer'' będzie od tego momentu odbierał wiadomości od
,,WSConnectora'', który został uruchomiony wraz z nim, i będzie odpowiadał za
należytą autentykację i/lub autoryzację użytkownika w usłudze czatu.

W chwili prawidłowego rozpoczęcia połączenia WebSocket, aplikacja po stronie
klienta wyświetli użytkownikowi okno autoryzacyjne. Wpisane tam dane zostaną
następnie przesłane do serwera. Po jego stronie, komunikat zostanie zdekodowany
przez aktora ,,WSConnector'' i przekazany powiązanemu aktorowi ,,Authorizer''.
Jego zadaniem będzie weryfikacja przedstawionych informacji oraz podjęcie
decyzji o autoryzacji lub jej odmowie. Decyzja ta jest odsyłana do
,,WSConnectora'' i następnie przekazywana do aplikacji po stronie klienta.

Za gromadzenie informacji związanych z autentykacją odpowiada jeden, na stałe
uruchomiony aktor o nazwie ,,UsernameLessor''. Jego zadaniem jest zarządzanie
informacjami na temat tymczasowych nazw użytkowników, należących do	użytkowników
bez stałych kont (ich gromadzenie, udzielanie, weryfikacja), a także weryfikacja
tożsamości kont administratorów.

Jezeli autentykacja przebiegnie pomyślnie, aktor ,,Authorizer'' uruchamia aktora
,,UserSession'', spina go z aktorem ,,WSConnector'' używanym wcześniej do
komunikacji z frontendem, oraz ulega autodestrukcji. Od tego momentu, aktor
,,UserSession'' przejmuje komunikację z użyciem ,,WSConnector'', pozwalając na
zwyczajne użytkowanie czatu. Aktor ,,UserSession'' gromadzi informacje na temat
nazwy oraz poziomu uprawnień użytkownika, a także tego, z jakim pokojem jest
obecnie spięty.

Kolejnym kluczowym aktorem, służącym do zarządzania pokojami, jest ,,Landlord''.
Jego zadaniem jest współudział w podpinaniu użytkowników do pokoju, tworzeniem
nowych i usuwaniem istniejących pokojów, a także utrzymywanie i udostępnianie
kompletnej listy aktywnych pokojów.

Za  obsługę każdego z poszczególnych pokojów odpowiada para aktorów: ,,Room'',
który działa jak router wiadomości i przechowuje listę użytkowników którzy
są do niego wpięci, oraz ,,MessageCache'', który przechowuje i odtwarza 10
najnowszych wiadomości wysłanych do pokoju.

Wreszcie, istnieje aktor ,,Architect'', który jest uruchamiany jako pierwszy
wraz z całym
serwerem, a także inicjalizuje i nadzoruje aktorów ,,WSListener'',
,,UsernameLessor'' oraz ,,Landlord''. W razie nieprawidłwego działania lub
wyłączenia któregokolwiek z tych trzech głównych aktorów, ,,Architect''
automatycznie zainicjuje przeładowanie całego serwera. Ponadto, ,,Architect''
potrafi w momencie uruchamiania serwera odczytać jego pliki konfiguracyjne i
na tej podstawie należycie skonfigurować pokoje oraz administratorów.

\subsubsection{Frontend}


\section{Projekt struktury}

\subsection{Diagram klas}

\section{Decyzje projektowe}

\subsection{Środowisko docelowe}

\subsection{Środowisko implementacji}

\subsection{Priorytety implementacyjne}

\section{Projekt algorytmów i przyjętych protokołów}

\subsection{Protokół frontend-backend}
Komunikacja pomiędzy frontendem a backendem...

\section{Projekt rozwiązań sprzętowych}

\section{Projekt interfejsu}

\subsection{Interfejs użytkownika}

\subsubsection{Założenia konstrukcji interfejsu}

\section{Projekt bazy danych}

\section{Opis implementacji}
