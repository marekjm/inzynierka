\documentclass[11pt,oneside,a4paper,titlepage,onecolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage[official]{eurosym}
\usepackage[polish]{babel}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{scrextend}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
% \usepackage{nameref}
% \usepackage{showlabels}
% \usepackage{titlesec}
\usepackage{geometry}
\geometry{a4paper, portrait, margin=2cm}



\setcounter{secnumdepth}{4}

%% Author and title
% \author{Marek Marecki \and Gr.52c \and Kod: 95 \and 2017\slash2018-2019}
\author{Marek Marecki \and Krzysztof Franek}
\title{%
    Proving viability of Viua VM \\
    \large Implementation of high-level language on Viua VM and\\
    deployment of a simple application \\
    ~\\
    Specyfikacja języka ViuAct}

\begin{document}

\lstset{language=Lisp,
basicstyle=\ttfamily,
columns=fixed}

\maketitle
{\footnotesize
\begin{center}
  \begin{tabular}{ | l | l | l | }
    \hline
    \parbox[t]{6.5cm}{\textbf{Temat pracy i akronim projektu:}\\Proving viablity of Viua VM (VVIA)} & \parbox[t]{4.5cm}{\textbf{Zleceniodawca:}\\\colorbox{yellow}{Nieznany}} & \parbox[t]{4.5cm}{\textbf{Konsultant:}\\\colorbox{yellow}{Nieznany}} \\ \hline
    \parbox[t]{6.5cm}{\textbf{Zespół projektowy:}\\Krzysztof Franek, Marek Marecki} & \parbox[t]{4.5cm}{\textbf{Kierownik projektu:}\\Marek Marecki} & \parbox[t]{4.5cm}{\textbf{Opiekun projektu:}\\dr hab. Marek A. Bednarczyk, prof. PJWSTK} \\ \hline
    \parbox[t]{3.5cm}{\textbf{Kierownik projektu:}\\Marek Marecki} & \multicolumn{2}{|l|}{\parbox[t]{9cm}{\textbf{Odpowiedzialny za dokument:}\\Krzysztof Franek}} \\ 
    \hline
  \end{tabular}
\end{center}
}

\tableofcontents
\newpage

\section{Specyfikacja języka Viuact}

\section{Model programowania}

\subsection{Podział programu}

Najmniejszym elementem możliwym do wykonania jest wyrażenie.
Wyrażenia są grupowane w funkcje.
Funkcje są zebrane w modułach.

\subsection{Wykonywanie programu}

Program składa się z jednego lub większej ilości ''aktorów'' (procesów).
Aktory są izolowane od siebie nawzajem i działają równolegle (wszystkie naraz).

Wewnętrznie, każdy z aktorów wykonywany jest sekwencyjnie, bez jakiejkolwiek
współbieżności.

\subsection{Komunikacja między aktorami}

Aktory komunikują się ze sobą za pomocą ''wymiany wiadomości''.
Wymiana wiadomości ma następujące cechy:

\begin{enumerate}
    \item jest asynchroniczna (nadawca nie jest blokowany do momentu aż odbiorca otrzyma
        wiadomość)
    \item nie daje gwarancji dostarczenia (nadawca nie ma gwarancji, że jego wiadomość
        dotrze do odbiorcy)
    \item nie daje gwarancji kolejności dostarczenia (nadawca nie ma gwarancji w jakiej
        kolejności wysłane przez niego wiadomości dotrą do odbiorcy)
\end{enumerate}

Ten model wymiany wiadomości jest warunkowany faktem, że nie jest fizycznie
możliwe zagwarantowanie poprawności komunikacji.

\subsection{Obsługa błędów}

Obsługa błędów jest realizowana za pomocą wyjątków. Viuact oferuje typową
składnię \texttt{try-catch}.

\newpage
\section{Typy danych}

\subsection{Typy proste}

\subsubsection{Liczba całkowita}

\emph{Liczba całkowita ze znakiem, o szerokości 64 bitów, kodowana z dopełnienem do
dwóch}

\subsubsection{Liczba zmiennoprzecinkowa}

\emph{Liczba zmiennoprzecinkowa o szerokości 64 bitów kodowana w standardzie IEEE 754-2008}

\subsubsection{Wartość boolowska}

\emph{Wartość logiczna reprezentująca prawdę lub fałsz o szerokości 8 bitów}

\subsubsection{Tekst}

\emph{Ciąg znaków Unicode, kodowany w formacie UTF-8}

\subsubsection{String}

\emph{Ciąg 8-bitowych bajtów}

\subsection{Typy złożone}

\subsubsection{Wektor}

\emph{Sekwencja wartości dowolnych typów danych, indeksowana od 0}

\subsubsection{Struktura}

\emph{Struktura agregująca wartości dowolnych typów danych, w której jedna
wartość jest mapowana do jednego pola}

\subsection{Typy platformy}

\subsubsection{PID}

\emph{Wartość identyfikująca aktora w programie}

Jest to typ dostarczany przez Viua VM. Dla programów pisanych w Viuact jest to
typ nieprzezroczysty.

\newpage
\section{Konstrukcje języka}

\subsection{Wyrażenia}

\texttt{expression := \emph{literal}
| \emph{name}
| \emph{fn-call}
| \emph{actor-call}
| \emph{operator-call}
| \emph{try-expr}
| \emph{if-expr}}
\\
\texttt{expression := \{ \emph{expression}+ \}}

\begin{lstlisting}
42
true
3.14
"Hello World!"
x
(print x)
(actor server_loop sock)
(+ x 1)

; compound expression
{ (let x 42) (print (+ x 1)) x }
\end{lstlisting}

Wyrażenia zwracają wartość, którą reprezentują. W przypadku literałów jest to wartość, którą bezpośrednio
reprezentują; w przypadku innych wyrażeń wartość ta jest określana na etapie wykonania (''\emph{run-time}'')
zależnie od wcześniejszego stanu programu.

Większość konstrukcji jezykowych oferowanych przez Viuact może być użyta jako wyrażenie.
Wyjątki to definicje zmiennych, definicje funkcji, definicje modułów, i przypisanie do pola struktury.

\subsubsection{Wyrażenia złożone}

Wyrażenia złożone są wyrażeniami składającymi się z kilku wyrażeń ograniczonych nawiasami klamrowymi.
Wyrażenia składowe wyrażenia złożonego są wykonywane po kolei, a końcowa wartość wyrażenia złożonego jest
wartością ostatniego wyrażenia składowego.

Wartością zwracaną wyrażenia złożonego przedstawionego poniżej będzie \texttt{42}:

\begin{lstlisting}
{
    (let x 42)
    (print x)
    x
}
\end{lstlisting}

Wyrażenia złożone mogą być dowolnie zagnieżdżane. Mimo iż składają się z potencjalnie wielu wyrażeń
wyrażenia złożone są traktowane jako jedno wyrażenie -- mogą być wykorzystywane wszędzie tam gdzie składnia
języka wymaga użycia pojedynczego wyrażenia:

\begin{lstlisting}
(let x {
    (let z (do_stuff))
    (print z)
    z
})
\end{lstlisting}

\subsection{Definicje zmiennych}

\texttt{let-binding := (let \emph{name} \emph{expression})}

\begin{lstlisting}
(let i 42)
(let f -3.14)
(let t "Hello World!")
\end{lstlisting}

Definicje zmiennych przypisują wartości wyrażeń do nazw.

\subsection{Definicje funkcji}

\texttt{function-definition := (let \emph{name} (\emph{formal-parameters}) \emph{expression})}

\begin{lstlisting}
(let f (x) (+ x 1))
(let f_with_print (x) {
    (print x)
    (+ x 1)
})
\end{lstlisting}

\subsubsection{Parametry formalne}

\texttt{formal-parameters := \emph{name}*}
\\

Parametry formalne (\emph{formal parameters}) są nazwami zmiennych widocznymi wewnątrz funkcji.
Parametry faktyczne (\emph{actual parameters}) są wartościami przypisywanymi parametrom formalnym na etapie
wykonania przez wywołującego.

\subsubsection{Ciało funkcji}

Ciało funkcji jest reprezentowane jednym wyrażeniem (może to być wyrażenie złożone).

\subsubsection{Wartość zwracana}

Wartość zwracana z funkcji jest wartością, do której ewaluuje wyrażenie będące jej ciałem.
Funkcje w Viuact to parametryzowane wyrażenia.

\subsection{Definicje modułów}

\texttt{inline-module-definition := (module \emph{module-name} (
\newline
\phantom{inline-module-definition := ~ }\emph{module-definition}*
\newline
\phantom{inline-module-definition := ~ }\emph{import}*
\newline
\phantom{inline-module-definition := ~ }\emph{function-definition}+
))}
\newline
\texttt{module-definition := (module \emph{module-name}) | \emph{inline-module-definition}}
\newline

Moduł jest zbiorem definicji modułów, deklaracji import, i definicji funkcji.
Taka kolejność w kodzie źródłowym nie jest wymagana, ale kompilator w takiej kolejności przetwarza konstrukcje
składające się na definicję modułu.

\subsection{Wywołanie funkcji}

\texttt{mod-prefix := \emph{module-name} "."}
\newline
\texttt{id := \emph{mod-prefix}*~\emph{name}}
\newline
\texttt{fn-call := (\emph{id} \emph{expression}*)}
\newline

Wywołanie funkcji jest reprezentowane przez podanie jej nazwy w nawiasach okrągłych, po której podane jest
zero lub więcej wyrażeń, których wartości zostaną przypisane do odpowiednich parametrów formalnych.

Funkcje, których definicje znajdują się w innych modułach niż aktualnie przetwarzany muszą być poprzedzone
pełną ścieżką do modułu, w którym są zdefiniowane (np. \texttt{Std.Posix.Network.socket}).

\subsection{Wywołanie ''tailcall''}

\texttt{(tailcall \emph{name} \emph{expression}*)}
\newline

Wywołania \emph{tailcall} powodują wywołanie funkcji nowej funkcje ''wykorzystując'' ramkę obecnej funkcji.
W praktyce powodują natychmiastowe zdjęcie obecnej ramki ze stosu (co powoduje destrukcję wszystkich wartości
w rejestrach lokalnych obecnej ramki, oraz uruchomienie wszelkich wywołań odroczonych) i wepchnięcie na szczyt
stosu ramki dla funkcji wywołanej \emph{tailcall}.

Wywołanie \emph{tailcall} nie ma bezpośredniej wartości zwracanej, ponieważ nie da się jej zaobserwować.
Wywołanie \emph{tailcall} ''porywa'' (ang. ''hijacks'') punkt, do którego powinna zwrócić wartość funkcja,
która wykonała takie wywołanie -- i dopiero ten punkt zaobserwuje de facto wartość zwróconą przez wywołanie
\emph{tailcall}, ale z jego punktu widzenia wygląda to tak jakby tą wartość zwróciła funkcja, którą on
bezpośrednio wywołał.

\begin{lstlisting}
(let g (x) (+ x 1))

(let f (x) (tailcall g x))  ; call frame of f() is replaced by g()

(let main () {
    (let i (f 41))  ; here, i will be bound to value returned by g()
    0
})
\end{lstlisting}

Podmiana ramki jest niedostrzegalna dla wywołującego oryginalną funkcję.

\subsection{Wywołanie odroczone}

\texttt{(defer \emph{name} \emph{expression}*)}
\newline

Wywołania odroczone nie są wywoływane od razu (jak zwykłe wywołania funkcji, bądź wywołania \emph{tailcall}),
ale dopiero w momencie, w którym ramka, w której zostały zarejestrowane jest zdejmowana ze stosu, niezależnie
od powodu dla którego jest ona zdejmowana -- czy będzie to zwykły powrót, odwinięcie stosu wywołane przez
wyjątek, czy wywołanie \emph{tailcall}.

Wywołania odroczone są wykonywane w odwrotnej kolejności rejestracji. Jeśli odroczone wywołanie \texttt{f()}
zostanie zarejestrowane przed odroczonym wywołaniem \texttt{g()}, to zostanie wykonane po nim. Dla przykładu:

\begin{lstlisting}
(let f () (print "from f()"))
(let g () (print "from g()"))
(let h () {
    (defer f)
    (defer g)
    (print "from h()")
    0
})
\end{lstlisting}

Wywołując funkcję \texttt{h()} na standardowym wyjściu pojawi się następujący tekst:

\begin{verbatim}
from h()
from g()
from f()
\end{verbatim}

Funkcja uruchomiona w wywołaniu odroczonym może zarejestrować swoje wywołania odroczone; takie wywołania
mogą być zagnieżdżane bez ograniczeń.

Wywołania odroczone są uruchamiane po zakończeniu działania funkcji, w której zostały zarejestrowane, ale
przed zniszczeniem wartości, które były umieszczone w jej zmiennych lokalnych. Ten fakt może zostać
wykorzystany do implementacji zarządzania zasobami -- jeśli wywołanie odroczone ma jakikolwiek uchwyt (np.
wskaźnik) do zasobu to może wykonać dla niego jakąś logikę finalizacji. W takim celu po utworzeniu zasobu
najlepiej od razu zarejestrować wywołanie odroczone, które dokona jego ''finalizacji''.

\begin{lstlisting}
(let f () {
    ; ...

    (let x (Some_module.reserve_resource))
    (defer Some_module.free_resource (Std.pointer x))

    ; ...
})
\end{lstlisting}

\subsection{Wywołanie aktora}

\texttt{(actor \emph{name} \emph{expression}*)}

\subsubsection{Fork-join}

Metoda \emph{fork-join} może być zrealizowana w Viuact za pomocą aktorów. Jeśli wynik wywołania aktora jest
przypisywany do zmiennej, to aktor będzie działał jako ''\emph{aktor potomny}'' aktora, który go wywołał. Taki
aktor potomny może być włączony (\emph{join}) za pomocą wywołania funkcji wbudowanej \texttt{Std.Actor.join()}
z biblioteki standardowej (opisanej na stronie \pageref{Std_Actor_join}).

\subsubsection{Wolne aktory}

\subsection{Wywołanie operatora}

\texttt{(\emph{operator} \emph{lhs} \emph{rhs})}

\subsection{Przypisanie do pola struktury}

\texttt{(:= \emph{field} \emph{expression})}

\subsection{Konstrukcja warunkowa}

\texttt{(if \emph{condition-expression} \emph{true-arm} \emph{false-arm})}

\subsection{Obsługa wyjątków}

\texttt{(try \emph{expression} (catch \emph{exception-tag} \emph{name} \emph{expression})+)}

\newpage
\section{Biblioteka standardowa}

Biblioteka standardowa języka Viuact składa się z modułów implementujących wybrane algorytmy (np. sortowanie)
i funkcjonalności (np. konwersje między typami danych), oraz umożliwia interakcję ze środowiskiem zewnętrznym
gdyż Viuact nie posiada wbudowanych w język mechanizmów takiej interakcji.

Część funkcji udostępnianych przez bibliotekę standardową jest niemożliwa do zaimplementowania w języku
Viuact. Takie funkcje są napisane albo w języku assemblera Viua VM, albo w języku C++.

Nie wszystkie funkcje biblioteki standardowej są ''normalnymi'' funkcjami, możliwymi do uruchomienia jako
aktor ponieważ niektóre z nich kompilują się do pojedynczych instrukcji maszyny (funkcje ''wbudowane'') albo
są napisane w języku C++, który jest niemożliwy do wywłaszczenia przez Viua VM (funkcje ''obce'').

Dla takich funkcji programista musi napisać \emph{wrappery} jeśli chce użyć ich jak w niektórych kontekstach.
Jednak w typowym programie nie będzie to potrzebne, gdyż funkcje biblioteki standardowej zazwyczaj
implementują atomowe zadania, których sens uruchamiania w osobnych aktorach jest ograniczony.

\subsection{\texttt{Std.Actor}}

\subsubsection{\texttt{Std.Actor.join()}}
\label{Std_Actor_join}

\subsubsection{\texttt{Std.Actor.self()}}
\subsubsection{\texttt{Std.Actor.receive()}}

\subsection{\texttt{Std.Io}}

Moduł udostępniający mechanizmy I/O (\emph{wejścia-wyjścia}). Umożliwia on prowadzenie I/O na plikach, oraz
interakcji z konsolą użytkownika (\texttt{tty}).

\subsubsection{\texttt{Std.Io.stdinxgetline}}

Umożliwia odczytanie pojedynczej linii ze strumienia standardowego wejścia (\emph{\texttt{stdin}}).

\subsection{\texttt{Std.Posix.Network}}

Moduł udostępniający implementację ''POSIX sockets''. Jest to cienka abstrakcja nad API dostarczanym przez
system operacyjny; w przypadku braków w tym dokumencie ich dokumentację można wydedukować ze stron manuala
sekcji 3 dostarczanych przez program \texttt{man(1)} (np. dokumentację dla funkcji
\texttt{Std.Posix.Network.socket} można uzyskać wykonując polecenie \texttt{man 3 socket}).

\subsubsection{\texttt{Std.Posix.Network.socket()}}
\subsubsection{\texttt{Std.Posix.Network.connect()}}
\subsubsection{\texttt{Std.Posix.Network.bind()}}
\subsubsection{\texttt{Std.Posix.Network.listen()}}
\subsubsection{\texttt{Std.Posix.Network.accept()}}
\subsubsection{\texttt{Std.Posix.Network.write()}}
\subsubsection{\texttt{Std.Posix.Network.read()}}
\subsubsection{\texttt{Std.Posix.Network.recv()}}
\subsubsection{\texttt{Std.Posix.Network.shutdown()}}
\subsubsection{\texttt{Std.Posix.Network.close()}}

\subsection{\texttt{Std.Random}}

Moduł udostępniający dostęp do liczb losowych ogólnego przeznaczenia (\texttt{/dev/urandom}) oraz zdatnych do
zastosowań kryptograficznych (\texttt{/dev/random}).

\newpage
\section{Interakcja z platformą}

''Platformą'' w przypadku Viuact jest Viua VM. Narzuca to pewne ograniczenia związane ze środowiskiem, w
którym programy napisane w języku Viuact można skompilować i uruchomić. Wynika to z faktu, że Viua VM sama w
sobie ma pewną platformę i wymagania.

\subsection{Platforma kompilacji}

Do kompilacji programów napisanych w Viuact potrzebny jest interpreter języka Python 3 w wersji co najmniej
3.6. Jest to jedyne ograniczenie, ponieważ na etapie kompilacji Viuact nie odwołuje się do żadnego elementu
Viua VM.

\subsection{Platforma asemblacji i linkowania}

Asemblacja i linkowanie odbywa się z użyciem narzędzi dostarczanych przez Viua VM.
Oprócz interpretera języka Python 3 potrzebny jest assembler dostarczany przez Viua VM. Oznacza to, że etap
asemblacji i linkowania może odbywać się jedynie na platformie zgodnej z POSIX-2008, wyposażonej w kompilator
obsługujący standard C++17 (są to wymagania Viua VM).

\subsection{Platforma uruchomieniowa}

Uruchomienie odbywa się w całości przy użyciu narzędzi dostarczanych przez Viua VM.
Ograniczenia i zależności są na tym etapie całkowicie zależne od wymagań narzucanych przez Viua VM.

\newpage
\section{Słownik}

\begin{labeling}{model aktorów}
    \item [model aktorów] model przetwarzania współbieżnego, opierający się na
        podstawowych strukturach, nazywanych „aktorami”, posiadających swój
        własny prywatny stan i porozumiewających się pomiędzy sobą za pomocą
        komunikatów
    \item [ViuAct] język wysokiego poziomu, oparty o modelu aktorów, kompilowany
        do języka asemblera Viua VM
    \item [Viua VM] maszyna wirtualna, umożliwiająca uruchamianie programów
        wykorzystujących współbieżność
    \item[runtime] ''\emph{środowisko uruchomieniowe}'' maszyna wirtualna bądź realna, na której
        wykonywany jest program
    \item[\emph{run-time}] ''\emph{czas wykonywania}'' czas, w którym program jest wykonywany przez VM;
        przeciwieństwo \emph{compile-time}
    \item[\emph{compile-time}] ''\emph{czas kompilacji}'' czas, w którym program jest kompilowany
\end{labeling}

\end{document}
