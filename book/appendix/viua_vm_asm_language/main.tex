\chapter{Język assemblera Viua VM}
\label{appendix_viua_vm_assembly_language}

W tym rozdziale zostanie omówiony język assemblera Viua VM -- jego składnia,
dostępne dyrektywy, oraz instrukcje. Wyjaśnione zostaną pojęcia takie jak
,,adres~rejestru'' i ,,tryby dostępu''. Zostaną przedstawione istniejące i
możliwe do wykorzystania zestawy rejestrów.

W dalszej części rozdziału (na stronie \pageref{appendix_viua_vm_assembly_language_ops})
przedstawiona zostanie dokumentacja zestawu instrukcji jakie oferuje
programistom Viua~VM.

\section{Składnia języka assemblera}

Składnia języka assemblera Viua VM jest prosta. Wyglądem przypomina składnię innych języków tego rodzaju
(np. języki assemblera x86 czy ARM).

\subsection{Ogólna składnia instrukcji}

Instrukcje składają się z mnemoniki, zera lub więcej adresów rejestrów, i co najwyżej jednego literału. Ogólną składnię można zapisać więc tak:

\begin{lstlisting}
mnemonic [<register>...] [<literal>]
\end{lstlisting}

Zanim pokazanych zostanie kilka przykładów ilustrujących różne warianty składni na konkretnych instrukcjach
należy zdefiniować czym jest ,,adres rejestru'' (lub, skrótowo, ,,rejestr''), a czym jest ,,literał''.

\begin{labeling}{\textbf{adres rejestru}}
	\item[\textbf{adres rejestru}] identyfikator informujący kernel VM skąd ma pobrać wartości do
		przetworzenia i gdzie zapisać wyniki działania instrukcji, w specjalnym przypadku adresem rejestru
		jest tzw. ,,\emph{rejestr pusty}'' -- \texttt{void}
	\item[\textbf{literał}] reprezentacja wartości wpisana dosłownie w kod źródłowy lub binarny,
		np. \texttt{0xdeadbeef}, \texttt{"Hello World!"}, \texttt{42}; do literałów zaliczane są też nazwy
		funkcji, bloków i modułów
\end{labeling}

\subsubsection{Adresy rejestrów}

\begin{lstlisting}
<access-operator> <index> <register-set>
void
\end{lstlisting}

\begin{labeling}{\texttt{access-operator}}
\item[\texttt{access-operator}] \texttt{\%} -- ,,dostęp bezpośredni'', lub
	\texttt{*} -- ,,dereferencja wskaźnika''
\item[\texttt{index}] indeks rejestru wewnątrz zestawu rejestrów
\item[\texttt{register-set}] nazwa zestawu rejestrów
\end{labeling}

Dostępne zestawy rejestrów to:

\begin{labeling}{\texttt{parameters}}
\item[\texttt{local}] zawiera wartości lokalne (,,zmienne lokalne'')
\item[\texttt{static}] zawiera wartości statyczne (,,zmienne statyczne'')
\item[\texttt{arguments}] zawiera wartości przekazane do aktywnej funkcji jako argumenty
\item[\texttt{parameters}] zawiera wartości przekazane do przygotowywanej ramki wywołania jako parametry
\end{labeling}

Podczas odczytu wartości adres \texttt{\%3 static} powoduje ,,dostęp do wartości w 3. statycznym rejestrze'';
\texttt{*4 local} powoduje ,,dostęp do wartości, na którą wskazuje wskaźnik w 4. lokalnym rejestrze''.

Wartości w rejestrach z zestawów \texttt{parameters} i \texttt{arguments} nie mogą być modyfikowane
bezpośrednio. Muszą być najpierw przeniesione lub skopiowane do rejestrów lokalnych lub statycznych.

\subsection{Definicje funkcji i bloków}

\begin{lstlisting}
.function: <name>/<arity>
	<instruction>
	[<instruction>...]
.end
\end{lstlisting}

\begin{lstlisting}
.block: <name>
	<instruction>
	[<instruction>...]
.end
\end{lstlisting}

\subsection{Deklaracje funkcji}

\begin{lstlisting}
.signature: <name>/<arity>
\end{lstlisting}

\subsection{Import modułów}

\begin{lstlisting}
.import: <module>[::<module>...]
\end{lstlisting}

\subsection{Markery}

\begin{lstlisting}
.mark: <marker-name>
\end{lstlisting}

\subsection{Nazywanie rejestrów}

\begin{lstlisting}
.name: <index> <name>
\end{lstlisting}

\newpage
\section{Instrukcje Viua VM}
\label{appendix_viua_vm_assembly_language_ops}

\input{appendix/viua_vm_asm_language/ops/value_management}
\input{appendix/viua_vm_asm_language/ops/boolean_logic}
\input{appendix/viua_vm_asm_language/ops/bit_ops}
\input{appendix/viua_vm_asm_language/ops/arithmetic_cpu}
\input{appendix/viua_vm_asm_language/ops/arithmetic_vm}
\input{appendix/viua_vm_asm_language/ops/text}
\input{appendix/viua_vm_asm_language/ops/vector}
\input{appendix/viua_vm_asm_language/ops/atom}
\input{appendix/viua_vm_asm_language/ops/struct}
\input{appendix/viua_vm_asm_language/ops/actor}
\input{appendix/viua_vm_asm_language/ops/functional}
\input{appendix/viua_vm_asm_language/ops/control_flow}
\input{appendix/viua_vm_asm_language/ops/error_handling}
\input{appendix/viua_vm_asm_language/ops/module_system}
