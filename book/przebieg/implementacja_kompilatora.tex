\section{Implementacja kompilatora}

Śledzenie prac nad rozwojem kompilatora było wspierane przez dwa narzędzia:
system kontroli wersji Git\footnote{\url{https://git-scm.com/}} i narzędzie do
śledzenia zadań Issue\footnote{\url{https://github.com/marekjm/issue}}.

\subsection{Zakończone zadania}

Poniżej przedstawiona jest lista zakończonych zadań zarejestrowanych do
wykonania podczas projektu.
Na dzień 2019-05-19 wykonane zostało $64.44\%$ zaplanowanych zadań. Tak niska
wartość wiąże się z tym, że część zadań zostało otwartych z założeniem, że mogą
nie zostać wykonane (na zasadzie ,,jeśli wystarczy czasu''). Mediana czasów
całkowitego czasu (od zgłoszenia do zamknięcia) każdego z ukończonych zadań to
nieco ponad sześć dni (6 dni i 11 godzin).

Repozytorium programu Issue jest dostępne wraz z repozytorium Git dołączonym
jako załącznik do projektu.

\subsubsection{Add an assembly driver tool for executables}

Identyfikator zadania: \texttt{5b8f77f4714be2c16d1f87a02b03692c96b983c1}
\newline
Rozpoczęte 2018-12-18 23:20:11, zakończone 2018-12-20 16:00:54.

\subsubsection{Basic CLI chat}

Identyfikator zadania: \texttt{b8cea1dc8ac19f63ad579ac28196c82f6a9eb7aa}
\newline
Rozpoczęte 2019-01-19 22:15:28, porzucone 2019-03-11 19:04:01.
\newline

Zadanie zostało porzucone ponieważ powstał czat oparty o protokół WebSocket.

\subsubsection{Create a module system}

Identyfikator zadania: \texttt{509ee8af1c2f503e402b34c18224a84caf4c9252}
\newline
Rozpoczęte 2018-11-22 19:26:21, zakończone 2018-11-29 06:54:16.
\newline

Język \ViuAct\phantom{} posiada działający system modułów opisany w rozdziale
\ref{viuact_spec_module_definition}~\nameref{viuact_spec_module_definition}.

\subsubsection{Create an EBNF notation to describe Viuact syntax}

Identyfikator zadania: \texttt{3295295f3d3b08cd0a3ae46c1adebe40bb3ebad4}
\newline
Rozpoczęte 2018-12-19 00:04:24, zakończone 2019-03-26 20:00:00.
\newline

Zadanie zostało zakończone po umieszczeniu w pracy specyfikacji języka \ViuAct,
która opisuje składnię w notacji EBNF. Specyfikacja znajduje się w rozdziale~\ref{viuact_spec}
na stronie \pageref{viuact_spec}.

\subsubsection{Dump intermediate representations}

Identifykator zadania: \texttt{902ffbd31e61d8446375620f8511042ca88f31e6}
\newline
Rozpoczęte 2019-01-07 18:42:28, zakończone 2019-01-07 19:43:09.
\newline

Zadanie polegało na umożliwieniu ,,podejrzenia'' tego na czym tak naprawdę
pracuje kompilator. W jego wyniku powstał mechanizm, który wymusza na
kompilatorze zapisanie do plików zserializowanej postaci strumienia tokenów,
AST, lub obu tych rzeczy.

Do zasygnalizowania kompilatorowi tej potrzeby wykorzystywana jest zmienna
środowiskowa. Przykłady użycia:

\begin{enumerate}
    \item \texttt{VIUAC\_DUMP\_INTERMEDIATE=tokens} -- zapis strumienia tokenów
    \item \texttt{VIUAC\_DUMP\_INTERMEDIATE=exprs} -- zapis AST
    \item \texttt{VIUAC\_DUMP\_INTERMEDIATE=tokens,exprs} -- zapis strumienia
        tokenów i AST
\end{enumerate}

\subsubsection{Emit dependency files for modules and executables}

Identifykator zadania: \texttt{f841ba29230081e4e6e8eba87857532ae98aff0a}
\newline
Rozpoczęte 2018-12-18 23:28:01, zakończone 2018-12-20 16:00:13.
\newline

Aby poprawnie połączyć moduły \texttt{viuact-opt} potrzebuje informacji o tym,
jakie moduły są importowane przez dany moduł lub plik wykonywalny. Te zależności
są zapisywane w plikach \texttt{.d} opisanych dokładnie w rozdziale
\ref{pliki_zaleznosci_modulow} na stronie \pageref{pliki_zaleznosci_modulow}.

\subsubsection{Emit interface files for modules}
\label{issue_86fd1a408cf62ecbebb7459b7d08298ce0a851bc}

Identifykator zadania: \texttt{86fd1a408cf62ecbebb7459b7d08298ce0a851bc}
\newline
Rozpoczęte 2018-12-18 23:13:55, zakończone 2019-03-27 18:09:37.
\newline

Kompilator podczas przetwarzania wyrażeń importowania modułów (rozdział
\ref{viuact_spec_module_import} na stronie \pageref{viuact_spec_module_import})
potrzebuje informacji o tym jakie funkcje i wyliczenia dany moduł udostępnia. Te
informacje zapisane są w plikach z interfejsami opisanych w rozdziale
\ref{pliki_interfejsow_modulow} na stronie \pageref{pliki_interfejsow_modulow}.

\subsubsection{Expose pointers}

Identifykator zadania: \texttt{3208ed0629487b2c02e14cfe5173a333bc364121}
\newline
Rozpoczęte 2019-02-02 14:18:22, zakończone 2019-02-02 19:55:44.
\newline

Kompilator języka \ViuAct\ potrafi śledzić to czy dana wartość jest wskaźnikiem
i automatycznie wstawić dereferencję w odpowiednim momencie jedynie dla
ograniczonego zakresu przypadków. W związku z tym potrzebne było udostępnienie
programistom narzędzi do bezpośredniej obsługi wskaźników. Tym narzędziami są
operator dereferencji (\texttt{\^}) i funkcja \texttt{Std.Pointer.take()}.

Nie było by to potrzebne gdyby kompilator języka \ViuAct\ wymagał weryfikacji
typów wartości na etapie kompilacji -- wtedy informacja o tym czy dana wartość
jest wskaźnikiem czy nie musiałaby być dostępna, a więc nie było by potrzeby
nadzorować tego ręcznie. Wskaźniki to jedno z miejsc gdzie brak czasu negatywnie
wpłynął na specyfikację i implementację języka.

\subsubsection{Expose the mechanism to set a process watchdog}

Identifykator zadania: \texttt{cc03c40b74d5ce2a7e9fa398ae0912c9a107b02d}
\newline
Rozpoczęte 2019-03-25 16:23:52, zakończone 2019-04-01 21:40:18.
\newline

\emph{Watchdog} to jeden z najważniejszych mechanizmów jakie język \ViuAct\ 
,,odziedziczył'' po Viua~VM. Jest to funkcja, która jest automatycznie
wywyoływana w momencie awarii procesu, aby
\begin{enumerate*}[label=(\arabic*)]
    \item zarejestrować wystąpienie awarii
    \item postawać się naprawić awarię restartując proces
    \item poinformować proces nadrzędny o awarii,
\end{enumerate*}
lub w jakikolwiek inny sposób zareagować na awarię, której główna funkcja
procesu nie dała rady obsłużyć.

Dokładny opis funkcji \emph{watchdog} znajduje się w rozdziale
\ref{viuact_spec_watchdog_call} na stronie \pageref{viuact_spec_watchdog_call}.

\subsubsection{Implement an exception catching mechanism}

Identifykator zadania: \texttt{d4bddf8f6b83c9957556465c8e9e112bddf747a1}
\newline
Rozpoczęte 2019-01-14 06:42:52, zakończone 2019-03-26 20:00:07.
\newline

Wyjątki to podstawowy sposób obsługi błędów w języku \ViuAct, a ich obsłużenie
jest pierwszą linią obrony przed awariami procesów.

\subsubsection{Implement an impressive example program}

Identifykator zadania: \texttt{b28ab36f969b4852a735850af1d1f509647b655c}
\newline
Rozpoczęte 2019-01-13 12:24:14, zakończone 2019-03-11 19:08:00.
\newline

W ramach tego zadania powstał prototypowy czat wykorzystujący protokół
WebSocket, który prezentowaliśmy m.in. na seminarium.

\subsubsection{Implement boolean values}

Identifykator zadania: \texttt{0050c352061a18221e21438e697c11d61c11a5a7}
\newline
Rozpoczęte 2019-01-07 18:23:12, zakończone 2019-01-07 18:23:37.
\newline

Wartości typu boolowskiego są istotnym elementem programów i mogą określać np.
czy dana funkcjonalność jest włączona lub wyłączona, czy autoryzacja się
powiodła lub nie, itd.

\subsubsection{Implement compound expressions}

Identifykator zadania: \texttt{d452c8ee6fcc4b245e7021fec2ceb0958aad1f84}
\newline
Rozpoczęte 2018-12-18 23:12:42, zakończone 2019-01-12 12:20:08.
\newline

Wyrażenia złożone (opisane w rozdziale \ref{language_expressions_compound} na
stronie \pageref{language_expressions_compound}) są jednym z ważniejszych
elementów języka. Pozwalają na pisanie funkcji wykonujących kilka operacji
dzięki temu, że umożliwiają zgrupowanie kilku prostszych wyrażeń w jedno.

\subsubsection{Implement proper imports inside Viua VM}

Identifykator zadania: \texttt{6f4f7baff22706628e7003303ff2aa0973460432}
\newline
Rozpoczęte 2018-12-22 16:08:28, zakończone 2019-01-14 06:41:41.
\newline

Mechanizm importowania modułów w Viua~VM był zbyt prymitywny żeby poradzić sobie
w elegancki sposób z importowaniem modułów jakie potrzebne było w języku
\ViuAct. Jedną z najbardziej oczywistych rzeczy, które musiały być poprawione w
samej maszynie wirtualnej było importowanie modułów obcych, które nie mogły być
linkowane statycznie do plików wykonywalnych lub modułów własnych Viua~VM i
musiały być linkowane dynamicznie.

Linkowanie dynamiczne musiało być wykonywane jawnie -- wykonywany program musiał
sam wykonać instrukcje odpowiadające za linkowanie modułu obcego. Po zakończeniu
tego zadania (i odpowiadającego mu zadania
\texttt{0f8c916c2499aab93cf8c55cc1fd6bbf354bd34d} w repozytorium Viua~VM) moduły
obce mogły być importowane automatycznie przez jądro Viua~VM dzięki dodaniu do
plików z bytecode sekcji informującej o modułach, które muszą być dolinkowane
dynamicznie. W pliku z kodem źródłowym w języku assemblera Viua~VM można
zarządać takiego dołączenia za pomocą następującego polecenia:
\begin{lstlisting}
.import: [[dynamic]] some::module
\end{lstlisting}

\subsubsection{Implement structs}

Identifykator zadania: \texttt{1f45e908dcde2f12b761da53183e2475619f64ef}
\newline
Rozpoczęte 2019-01-02 21:13:48, zakończone 2019-01-06 12:03:04.
\newline

Struktury w języku \ViuAct\ są sposobem na tworzenie nowych typów przez
programistę. Bez nich, tworzenie nietrywialnego oprogramowania byłoby mocno
utrudnione. Struktury są opisane w rozdziale \ref{viuact_spec_datatypes_aggregate_struct}
na stronie \pageref{viuact_spec_datatypes_aggregate_struct}.

\subsubsection{Implement tail calls}

Identifykator zadania: \texttt{b680202a36a7358006d87cf371686fc2d42aecdc}
\newline
Rozpoczęte 2019-01-06 22:02:12, zakończone 2019-01-06 22:04:33.
\newline

Wywołania w pozycji ogonowej są przydatne w wielu miejscach: przy obsłudze
błędów (gdzie pozwalają zastąpić funkcję \emph{watchdog} nową funkcją,
restartując proces bez zmiany jego PID), zastępują pętle, oraz pozwalają
implementować wzorzec ,,inicjalizacja-implementacja'' (rozdział
\ref{viuact_spec_tail_call_use_case} na stronie
\pageref{viuact_spec_tail_call_use_case}).

\subsubsection{Implement vectors}

Identifykator zadania: \texttt{c499f685c5736b3a282ed81251f2d1bd869e3684}
\newline
Rozpoczęte 2019-01-10 06:46:42, zakończone 2019-01-12 12:18:49.
\newline

Wektory są podstawowym typem danych używanym do przechowywania kilku wartości
tego samego typu (mają to samo zastosowanie co tablice i listy).

\subsubsection{Integrate FFI imports}

Identifykator zadania: \texttt{713ebf5bc4359b8c74222228e55fcad8d5a7dd05}
\newline
Rozpoczęte 2019-01-12 15:25:56, zakończone 2019-01-13 12:22:32.
\newline

To zadanie jest powiązane z zadaniem \texttt{86fd1a408cf62ecbebb7459b7d08298ce0a851bc}
(rozdział \ref{issue_86fd1a408cf62ecbebb7459b7d08298ce0a851bc} na stronie
\pageref{issue_86fd1a408cf62ecbebb7459b7d08298ce0a851bc}). Importowanie modułów
obcych wymagało zdefiniowania jak napisać plik interfejsu ręcznie, oraz dodania
do kompilatora logiki odpowiedzialnej za importowanie modułów obcych.

\subsubsection{Make function bodies a single expression}

Identifykator zadania: \texttt{0d911ab770e326a692cb06170eeaf32acc54b50a}
\newline
Rozpoczęte 2018-11-29 06:55:06, zakończone 2019-01-12 12:13:41.
\newline

Ciała funkcji w pierwotnej wersji języka \ViuAct\ nie były pojedynczymi
wyrażeniami tylko sekwencjami wyrażeń, co wymagało specjalnego kodu do obsługi.
Było to niepotrzebne i duplikowało ,,funkcjonalności'' języka, które były
zawarte w wyrażeniach złożonych -- znaczenie programu nie zmieniałoby się
niezależnie od tego czy ciało funkcji byłoby sekwencją wyrażeń czy pojedynczym
wyrażeniem złożonym (które samo jest sekwencją wyrażeń).

\subsubsection{Make functions first class values}

Identifykator zadania: \texttt{04dd87b88783077ea7ba64c57e9aa2aa1e8f5f76}
\newline
Rozpoczęte 2019-03-26 19:10:55, zakończone 2019-03-26 19:58:43.
\newline

Zdefiniowanie funkcji jako możliwych do przekazania jako argumenty, możliwych do
zwrócenia jako wynik działania innych funkcji, itd. jest niezwykle przydatne.
Funkcje jako wartości pierwszoklasowe\footnote{Wartości pierwszoklasowe
(ang. \emph{first-class values}) są wartościami, które można
\begin{enumerate*}[label=(\arabic*)]
    \item dowiązać do zmiennej
    \item przekazać jako argument do funkcji
    \item zwrócić jako wynik działania funkcji.
\end{enumerate*}
W języku \ViuAct\ istnieje mało rzeczy, których nie
można wykorzystać w ten sposób -- moduły, literały timeoutów i definicje
wyliczeń. Są to wartości drugoklasowe (ang. \emph{second-class values}).} w
języku \ViuAct\ pozwalają na implementację m.in. funkcji w rodzaju
\texttt{for\_each()} czy \texttt{map()}.

\subsubsection{Make the compiler installable}

Identifykator zadania: \texttt{6b5d4b13a50dd9397c4db7cf326fcd2e6dbfabef}
\newline
Rozpoczęte 2019-03-28 22:00:26, zakończone 2019-04-01 21:40:55.
\newline

To zadanie było bardzo istotne ponieważ jeśli kompilatora języka \ViuAct\ dałoby
się używać jedynie z katalogu, w którym znajduje się jego kod źródłowy to jego
użyteczność byłaby mocno ograniczona.

\subsubsection{Remove the parentheses around function args}

Identifykator zadania: \texttt{bb64aeee220ffe1f0cebd7aaf01f19fd972845f5}
\newline
Rozpoczęte 2018-11-29 07:05:02, zakończone 2018-11-29 07:13:12.
\newline

W wyniku tego zadania składnia wywołań funkcji zmieniona z
\begin{lstlisting}
(fn (arg foo bar))
\end{lstlisting}
na
\begin{lstlisting}
(fn arg foo bar)
\end{lstlisting}
Te dodatkowe nawiasy dookoła argumentów funkcji były nadmiarowe i można je było
usunąć ze specyfikacji bez strat dla języka.

\subsubsection{Rework README for the Issue project}

Identifykator zadania: \texttt{734808030c94028eef293326119d79ffff0d855d}
\newline
Rozpoczęte 2018-12-22 16:14:59, zakończone 2019-03-11 19:04:44.
\newline

To zadanie musiało być wykonane aby wszyscy członkowie zespołu mogli nauczyć się
korzystać z narzędzia do śledzenia zadań wykorzystywanego przy pracach nad
kompilatorem języka \ViuAct.

\subsubsection{Specify the module system}

Identifykator zadania: \texttt{242ef1a8f720ff43d6828708277a917a7b977e59}
\newline
Rozpoczęte 2018-12-18 23:37:37, zakończone 2019-03-26 19:59:47.
\newline

To zadanie jest tutaj wyszczególnione jako jedyne z zadań polegających na
wyspecyfikowaniu pewnych działań czy konstrukcji ponieważ jako jedyne wymagało
zdefiniowania jakie produkty powinien generować kompilator języka \ViuAct\ żeby
móc się skomunikować z samym sobą -- tylko system modułów wymaga żeby kompilator
(\texttt{viuact-cc}) przetwarzał swoje własne pliki wynikowe.

Obejmowało to między innymi takie problemy jak zapis interfejsu modułów, zapis
tego od jakich innych modułów zależy dany moduł, czy to jak moduły zdefiniowane
\emph{inline} powinny być zapisane w katalogu z plikami wynikowymi. Jest to
zadanie unikalne pod względem tego jak dużą interakcję z systemem plików
prowadzi kompilator języka \ViuAct\ podczas wykonywania operacji związanych z
nim.

\subsubsection{Suppress unused register errors thrown by Viua VM assembler}

Identifykator zadania: \texttt{cd43ec37335b40816059fca8f984088ebfac6339}
\newline
Rozpoczęte 2018-12-19 11:25:00, zakończone 2018-12-19 11:26:13.
\newline

To zadanie polegało na wyłączeniu części analizy statycznej jaką przeprowadza
assembler Viua~VM poprzed wywoływanie go z flagą \texttt{-Wunused-value}.
Kompilator języka \ViuAct\ generuje kod, który jest poprawny, ale czasami zbyt
skomplikowany dla silnika analizy statycznej, który działa wewnątrz assemblera
Viua~VM i bardzo często generował fałszywe alarmy.

Z uwagi na presję czasu fragment analizy statycznej odpowiadający za odrzucenie
programu, który zawiera nieużywane wartości nie został poprawiony, a jedynie
wyłączony.

\subsubsection{Test the compiler and assembly driver}

Identifykator zadania: \texttt{561ce14aef1f418849c436eb3bde6bb5c35c03ad}
\newline
Rozpoczęte 2018-12-19 00:05:20, zakończone 2019-03-26 20:00:23.
\newline

Zadanie zostało zakończone w momencie, w którym większa część języka została już
udokumentowana w specyfikacji i zaimplementowana w kompilatorze. Polegało na
przygotowaniu zestawu testów pokrywającego każdą możliwą konstrukcję językową --
czyli stworzenie testu dla konstrukcji warunkowej, wyrażenia złożonego,
definicji modułu, itd. Zadanie \textbf{nie} obejmowało stworzenia zestawu testów
obejmującego kombinacje konstrukcji językowych ponieważ nie jest możliwe
stworzenie takiego zestawu z uwagi na to, że ilość takich kombinacji jest
nieskończona.

\subsubsection{Write websockets FFI module}

Identifykator zadania: \texttt{631bce2891cc7368c68e010a50e04bd55ffbaf03}
\newline
Rozpoczęte 2018-12-19 00:00:24, zakończone 2019-03-11 19:06:19.
\newline

Istniejące biblioteki implementujące protokoł WebSocket, które były brane pod
uwagę do wykorzystania to \url{https://libwebsockets.org} i
\url{https://github.com/zaphoyd/websocketpp}. Obie jednak zostały odrzucone ze
względu na duży narzut koncepcyjny i poziom skomplikowania API (konieczność
tworzenia obiektów zarządzających, klas, itd.) oraz konieczność wykorzystania
\emph{event loops} dostarczanych przez te biblioteki.

Wykorzystanie \emph{event loop} dyskwalifikuje jakąkolwiek bibliotekę, która
używa takiego modelu programowania ponieważ wymusza on przekazanie kontroli nad
wykonaniem programu z Viua~VM do jakiegoś zewnętrznego programu, co całkowicie
niweluje jakiekolwiek gwarancje zapewniane przez Viua~VM.

Oprócz tego czysto technicznego powodu odrzucenia istniejących bibliotek jest
jeszcze powód subiektywny: stopień ich skomplikowania jest odpychający. Zamiast
wystawić socket i udostępnić proste API pozwalające na odczytywanie i zapiswanie
wiadomości oraz nawiązywanie i zrywanie połączenia, a kontrolę zostawić w rękach
programu, który będzie ich używał -- wymagają oddania kontroli w ich ,,ręce'' i
wpinania się w ich \emph{event loop}.

Zamiast pozwolić wziąć się jako zakładnika, zadecydowaliśmy o implementacji
biblioteki zapewniającej obsługę protokołu WebSocket od zera. Ta biblioteka jest
opisana w dodatku \ref{plain_websocket_library} na stronie
\pageref{plain_websocket_library}.
